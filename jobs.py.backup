import logging
from api import get_all_alerts, get_all_events
import db
import config
from handlers import send_alert_message
import asyncio
from telegram.constants import ParseMode
from utils import format_event_message, split_text, is_admin
from telegram.ext import ContextTypes
from datetime import date, timedelta
from typing import List, Dict, Any
from telegram import Update
# --- Функції для фонових завдань ---
async def check_for_alerts(context: ContextTypes.DEFAULT_TYPE) -> None:
    """Перевіряє наявність повітряних тривог та надсилає сповіщення."""
    try:
        logging.info("Перевіряю повітряні тривоги...")
        db_session = context.bot_data['db_session']
        aiohttp_session = context.bot_data['aiohttp_session']
        alerts = await get_all_alerts(aiohttp_session)
        # Перевірка на випадок, якщо API не повернуло даних
        if alerts is None:
            logging.error("Не вдалося отримати дані про тривоги. Пропускаю перевірку.")
            return
        # Логуємо всі активні тривоги по всій Україні
        all_active_alerts = [alert.location_title for alert in alerts if alert.alert_type == 'air_raid']
        logging.info(f"Активні тривоги по Україні: {all_active_alerts}")
        current_alerts = await db.get_last_alerts_state(db_session)
        # Нова логіка: якщо в базі даних немає даних про попередні тривоги,
        # це означає, що бот тільки-но запустився.
        # У цьому випадку ми просто зберігаємо поточний стан і не надсилаємо сповіщень.
        if not current_alerts:
            logging.info("Бот тільки-но запустився. Зберігаю поточний статус тривог без надсилання сповіщень.")
            await db.save_alerts_state(db_session, all_active_alerts)
            return
        # Перевірка на відбій тривоги ТІЛЬКИ для Одеської області
        if 'Одеська область' in current_alerts and 'Одеська область' not in all_active_alerts:
            logging.info("Відбій у регіоні: Одеська область")
            await db.save_alerts_state(db_session, [r for r in current_alerts if r != 'Одеська область'])
            await send_alert_message(context, config.XYA_CHANNEL_ID, {'location_title': 'Одеська область'}, is_start=False, sticker_id='CAACAgIAAxkBAAERtjJorLtblGjBbtREQeYP31RfgVoDQwACSIkAAsSAYUnxGAxeP4qvPjYE')
        # Перевірка на нову тривогу ТІЛЬКИ для Одеської області
        elif 'Одеська область' not in current_alerts and 'Одеська область' in all_active_alerts:
            logging.info("Нова тривога у регіоні: Одеська область")
            await db.save_alerts_state(db_session, all_active_alerts)
            await send_alert_message(context, config.XYA_CHANNEL_ID, {'location_title': 'Одеська область'}, is_start=True, sticker_id='CAACAgIAAxkBAAERtj9orLytPDjfsqmwzT1EW9KJ5wIK8gACfIYAAldXaElGJIq9peSKpjYE')
    except Exception as e:
        logging.error(f"Помилка в завданні check_for_alerts: {e}", exc_info=True)
async def send_events_today(context: ContextTypes.DEFAULT_TYPE) -> None:
    """Відправляє в канал події на сьогоднішній день."""
    try:
        db_session = context.bot_data['db_session']
        aiohttp_session = context.bot_data['aiohttp_session']
        all_events = await get_all_events(aiohttp_session)
        today = date.today().strftime("%d.%m.%Y")
        today_events = [e for e in all_events if e.get('date') == today]
        if not today_events:
            logging.warning("Події на сьогодні не знайдені.")
            return
        for event in today_events:
            is_sent = await db.is_event_sent(db_session, event['url'])
            if not is_sent:
                logging.info(f"Публікую подію: {event['title']} у канал.")
                await db.add_sent_event(db_session, event['url'])
                message_text = format_event_message(event, is_today=True)
                messages_to_send = split_text(message_text, max_length=4000)
                for part in messages_to_send:
                    try:
                        await context.bot.send_message(chat_id=config.XYA_CHANNEL_ID, text=part, parse_mode=ParseMode.MARKDOWN)
                    except Exception as e:
                        logging.error(f"Не вдалося опублікувати подію в канал {config.XYA_CHANNEL_ID}: {e}", exc_info=True)
    except Exception as e:
        logging.error(f"Помилка в завданні send_events_today: {e}", exc_info=True)
async def send_events_tomorrow(context: ContextTypes.DEFAULT_TYPE) -> None:
    """Відправляє в канал події на завтрашній день."""
    try:
        db_session = context.bot_data['db_session']
        aiohttp_session = context.bot_data['aiohttp_session']
        all_events = await get_all_events(aiohttp_session)
        tomorrow = (date.today() + timedelta(days=1)).strftime("%d.%m.%Y")
        tomorrow_events = [e for e in all_events if e.get('date') == tomorrow]
        if not tomorrow_events:
            logging.warning("Події на завтра не знайдені.")
            return
        for event in tomorrow_events:
            is_sent = await db.is_event_sent(db_session, event['url'])
            if not is_sent:
                logging.info(f"Публікую подію: {event['title']} у канал.")
                await db.add_sent_event(db_session, event['url'])
                message_text = format_event_message(event, is_today=False)
                messages_to_send = split_text(message_text, max_length=4000)
                for part in messages_to_send:
                    try:
                        await context.bot.send_message(chat_id=config.XYA_CHANNEL_ID, text=part, parse_mode=ParseMode.MARKDOWN)
                    except Exception as e:
                        logging.error(f"Не вдалося опублікувати подію в канал {config.XYA_CHANNEL_ID}: {e}", exc_info=True)
    except Exception as e:
        logging.error(f"Помилка в завданні send_events_tomorrow: {e}", exc_info=True)
# === НОВІ АДМІНІСТРАТИВНІ ФУНКЦІЇ ===
async def force_check_alerts(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Адміністративна команда для примусової перевірки тривог."""
    if not is_admin(update.effective_user.id):
        await update.message.reply_text("У вас немає прав адміністратора для цієї команди.")
        return
    await update.message.reply_text("Починаю примусову перевірку повітряних тривог...")
    await check_for_alerts(context)
    await update.message.reply_text("Примусову перевірку тривог завершено.")
async def force_send_events_today(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Адміністративна команда для примусового відправлення подій на сьогодні."""
    if not is_admin(update.effective_user.id):
        await update.message.reply_text("У вас немає прав адміністратора для цієї команди.")
        return
    await update.message.reply_text("Починаю примусове відправлення подій на сьогодні...")
    await send_events_today(context)
    await update.message.reply_text("Примусове відправлення подій на сьогодні завершено.")
async def force_send_events_tomorrow(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Адміністративна команда для примусового відправлення подій на завтра."""
    if not is_admin(update.effective_user.id):
        await update.message.reply_text("У вас немає прав адміністратора для цієї команди.")
        return
    await update.message.reply_text("Починаю примусове відправлення подій на завтра...")
    await send_events_tomorrow(context)
    await update.message.reply_text("Примусове відправлення подій на завтра завершено.")
